repo_orientation_task:
  description: >
    You are a senior software engineer performing an initial repository orientation.

    Your goal is to understand what this project does and how it is structured,
    using the minimum amount of reading necessary.

    First, list the top-level repository structure (depth <= 2),
    but DO NOT open or list anything under:
    - .git/
    - build/ or out/
    - binary, object, or generated files

    Then, read ONLY documentation files in the repository root:
    - README*
    - other *.md files in the root directory

    Do NOT read source code files at this stage.

    Based on the documentation and shallow structure, produce a concise project brief
    that would help another engineer quickly understand the project.
  expected_output: >
    ## Project Summary
    ## Build & Run
    ## Testing
    ## Key Directories
    ## Entry Points / Core Components
    ## Unknowns / Next Things to Inspect
context_selection_task:
  description: >
    You are responsible for selecting which files should be reviewed in detail.

    Your role is to act like an experienced engineer onboarding into an unfamiliar
    codebase: you decide WHAT to read next and HOW deeply to read it, before any
    actual code review happens.

    You will be given:
    - a project brief produced by another agent (high-level understanding from documentation)
    - a list of repository files with metadata only (path, size, extension, timestamps)

    Your task is to produce a concrete, bounded reading plan that determines
    which files should be opened and reviewed in the next step.

    === HARD CONSTRAINTS (MUST FOLLOW) ===

    - You MUST NOT read or infer the contents of any file.
      You only have access to file paths and metadata.

    - You MUST select at most 40 files in total.

    - Each selected file MUST respect a maximum read budget of 8000 characters.
      Budgets should be distributed intentionally; not all files should use the maximum.

    - You may ONLY select the following file types:
      - *.cpp, *.hpp, *.h, *.c
      - CMakeLists.txt and *.cmake
      - source files under the tests/ directory

    - You MUST NOT select anything under:
      - .git/
      - build/ or out/
      - binary, object, library, or generated files

    - You MUST NOT select third-party implementation files by default.
      If third-party code is relevant, prefer headers only and only when necessary
      to understand how the project uses the dependency.

    === REASONING AND SELECTION GUIDELINES ===

    - Follow human code-reading logic:
      - start from build configuration and entry points
      - then inspect core components and shared types
      - then inspect a small number of representative test files

    - Prefer representative sampling over exhaustive coverage.
      Reading a few well-chosen test files is better than reading many similar ones.

    - Avoid redundant files (e.g., multiple similar test cases) unless there is a
      clear reason to believe they exercise different behavior.

    - If uncertain about a fileâ€™s importance, prefer a shallow read strategy
      (head or search) before committing to a full read.

    === HOW TO WRITE REASONS (VERY IMPORTANT) ===

    - For each selected file, you MUST explain:
      1) WHY the file is being selected
      2) WHAT you intend to confirm or learn by reading it

    - Reasons MUST be framed as hypotheses or inspection goals.
      You MUST NOT state concrete implementation details or claims about file contents
      that you have not read.

      Examples:
      - GOOD: "Likely program entry point based on naming and build structure; inspect to confirm main control flow."
      - BAD:  "Contains the SnakeGame class and AI combat system."

    === READ STRATEGY DEFINITIONS ===

    - full:
      Read the entire file up to the specified character budget.
      Use this only for entry points, core components, or small representative tests.

    - head:
      Read only the top portion of the file (e.g., includes, declarations, configuration,
      or high-level structure). Use for headers, configuration, or large files.

    - search:
      Perform a targeted scan for relevant identifiers or patterns (e.g., main(),
      target definitions, file references). Use when locating entry points or dependencies.

    === OUTPUT REQUIREMENTS ===

    - Output MUST be a single valid JSON object.
    - Do NOT include explanations, markdown, or extra text outside the JSON.
    - Ensure the output strictly follows the required schema.

  expected_output: >
    A single valid JSON object with the following structure:

    {
      "max_files": 40,
      "max_chars_per_file": 8000,
      "selected_files": [
        {
          "path": "string",
          "reason": "string",
          "read_strategy": "full|head|search",
          "char_budget": 8000
        }
      ]
    }
code_review_task:
  description: >
    You are a senior C++ code reviewer.

    You will be given a reading plan that specifies exactly which files
    are allowed to be opened and reviewed.

    You MUST strictly follow the reading plan:
    - Do NOT open any file that is not listed in the plan.
    - Respect the per-file character budget.

    Review the selected files for:
    - correctness
    - security
    - performance
    - readability
    - maintainability

    When you comment, you MUST include:
    - the file path
    - a quoted snippet (exact lines you saw)
    - an actionable suggestion

    Output MUST be raw markdown. Do NOT wrap in triple backticks.
  expected_output: >
    ## Summary
    ## Blocking Issues (file path + snippet)
    ## Non-blocking Suggestions (file path + snippet)
    ## Testing Feedback
    ## Verdict (APPROVE or REQUEST_CHANGES)
  agent: code_reviewer
review_json_task:
  description: >
    You will be given a markdown code review produced by another agent.

    Your job is to extract a strict JSON object that summarizes the review.

    Rules:
    - ONLY use information explicitly present in the markdown.
    - Do NOT invent new issues, files, snippets, or severities.
    - If something is missing, leave it empty or null.
    - Output MUST be valid JSON and NOTHING else.

    Required JSON schema:
    {
      "verdict": "APPROVE|REQUEST_CHANGES|UNKNOWN",
      "summary": "short string",
      "issues": [
        {
          "severity": "BLOCKING|NON_BLOCKING",
          "category": "Security|Correctness|Performance|Build|Tests|Style|Other",
          "file": "string",
          "snippet": "string",
          "suggestion": "string",
          "acceptance_criteria": "string or null"
        }
      ]
    }
  expected_output: >
    A single valid JSON object, no markdown, no explanation.
  agent: json_generator
